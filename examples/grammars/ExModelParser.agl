// This file contains the grammar for the ProjectIt Example project
// which is input to the AGL parser.
// It is a transformed version of the grammar that is generated by ProjectIt.
// Any errors could be either in the generation, the transformation to AGL format, or ...

namespace test
grammar PiExample {
    skip WHITE_SPACE = "\s+" ;
    skip MULTI_LINE_COMMENT = "/\*[^*]*\*+(?:[^*/][^*]*\*+)*/" ;
    skip SINGLE_LINE_COMMENT = "//.*?$" ;

ExModel = 'model' variable '{'
	(Entity)*
	'model' 'wide' 'Methods:'
	MethodList2
	'}' ;

Entity = 'Entity' variable ('base' EntityPiElemRef )? '{'
    	AttributeList3
    	MethodList4
    	'}' ;

Attribute = variable ':' TypePiElemRef; 

Method = 'method' variable '(' ParameterList5 '):' TypePiElemRef '{' 
	ExExpression 
	'}' ;

ExExpression = LiteralExpression 
    | AbsExpression 
    | ParameterRef 
    | LoopVariableRef 
    | SumExpression 
    | MethodCallExpression 
    | IfExpression 
    | BinaryExpression ;

LiteralExpression = StringLiteralExpression 
    | NumberLiteralExpression 
    | BooleanLiteralExpression ;

StringLiteralExpression = ''' stringLiteral ''' ;

AppliedFeature = AttributeRef ;

AttributeRef = AttributePiElemRef ;

NumberLiteralExpression = stringLiteral ;

BooleanLiteralExpression = stringLiteral ;

AbsExpression = 'abs(' ExExpression ')' ;

ParameterRef = ParameterPiElemRef '.' AppliedFeature ;

LoopVariableRef = LoopVariablePiElemRef ;

SumExpression = 'sum' 'from' LoopVariable '=' ExExpression 'to' ExExpression 'of' ExExpression;

LoopVariable = variable;

MethodCallExpression = 'CALL' MethodPiElemRef '(' ExExpressionList6 ')' ;

IfExpression = 'if' '(' ExExpression ')' 'then' 
	ExExpression
	'else' 
	ExExpression
	'endif';

BinaryExpression = MultiplyExpression
    | PlusExpression
    | DivideExpression
    | AndExpression
    | OrExpression 
    | ComparisonExpression;

MultiplyExpression = '(' ExExpression '*' ExExpression ')';
    
PlusExpression = '(' ExExpression '+' ExExpression ')';
    
DivideExpression = '(' ExExpression '|' ExExpression ')';
    
AndExpression = '(' ExExpression 'and' ExExpression ')';
    
OrExpression = '(' ExExpression 'or' ExExpression ')';
    
ComparisonExpression = LessThenExpression 
    | GreaterThenExpression
    | EqualsExpression;

LessThenExpression = '(' ExExpression '<' ExExpression ')';
    
GreaterThenExpression = '(' ExExpression '>' ExExpression ')';

EqualsExpression = '(' ExExpression '==' ExExpression ')';
    
Parameter = variable  ':'  TypePiElemRef;

EntityPiElemRef = variable;

TypePiElemRef = variable;

AttributePiElemRef = variable;

ParameterPiElemRef = variable;

LoopVariablePiElemRef = variable;

MethodPiElemRef = variable;

MethodList2 = Method*;

AttributeList3 = Attribute*;

MethodList4 = Method*;

ParameterList5 = [Parameter / ',']*; // comma-separated list

ExExpressionList6 = [ExExpression / ',']*; // comma-separated list

anyChar             = "[a-zA-Z0-9' ]";
number              = "[0-9]";

leaf variable            = "[a-zA-Z_][a-zA-Z0-9_]*" ;
leaf stringLiteral       = '"' anyChar* '"';
leaf numberLiteral       = number+;
leaf booleanLiteral      = 'false' | 'true';


/* TODO the following rules do not work in AGL
varLetter1           = '[a-zA-Z]';
identifierChar1      = '[a-zA-Z0-9_$]'; // any char but not /.,!?@~%^&*-=+(){}'':;<>?[]'/
anyChar1             = '[a-zA-Z0-9' /\-\[\]\'+<>=#$_.,!?@~%^&\*-=(){}:;<>?]';
number1              = '[0-9]';

leaf variable1            = varLetter identifierChar*;
leaf stringLiteral1       = '"' anyChar* '"';
leaf numberLiteral1       = number+;
leaf booleanLiteral1      = 'false' | 'true';
*/
//TODO extend anyChar with ? + *
/* TODO see whether the rest of the rules in pegjs can be replaced by the rules in the prefix */

}
